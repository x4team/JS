function init () {

//Наш объект ПРЕДСТАВЛЕНИЯ
var view = {
	//метод получает строковое сообщение и выводит его
	//в области сообщений
	displayMessage: function(msg) { //Метод displayMessage получает один аргумент - текст сообщения
		var messageArea = document.getElementById("messageArea"); //Мы получаем элемент messageArea из страницы
		messageArea.innerHTML = msg; //..и обновляем текст элемента messageArea, задавая его свйству innerHTML содержимое msg
	},

	displayHit: function(location) {
		var cell = document.getElementById(location); //Получаем идентификатор, созданный по введенным пользователям координатам
		cell.setAttribute("class", "hit"); //Добавляем класс hit к элементу ячейки
	},

	displayMiss: function(location) {
		var cell = document.getElementById(location);
		cell.setAttribute("class", "miss");
	}
};

//Объект модели
var model = {
	boardSize: 7, //Эти 3 свойства помогают обойтись без жесткого фиксированных значений:
	numShips: 3,  // boardSize (размер игрового поля), numSships (количество кораблей в игре),
	shipLength: 3,// и shipLength (длина корабля в клетках, 3)
	shipsSunk: 0, // <- Свойство инициализируется значением 0 в начале игры, содержит текущее кол-во потопленных кораблей
	/* Свойство ships содержит массив объектов ship, содержащих массивы locations и hits для одного из трех
	   кораблей. (Обратите внимание, что использовавшаяся ранее переменная ships заменена свойством объекта модели) */	
	ships: [ { locations: ["06", "16", "26"], hits: ["", "", ""] }, // Позднее позиции кораблей будут генерироваться 
			 { locations: ["24", "34", "44"], hits: ["", "", ""] }, // случайным образом
			 { locations: ["10", "11", "12"], hits: ["", "", ""] }], //
	//Метод для выполнения выстрела и проверки результата (промах или попадание).		 
    fire: function(guess) { //метод получает координаты выстрела
    	for (var i = 0; i < this.numShips; i++){ //Затем перебираем массив ships, последовательно проверяя каждый корабль.
    		var ship = this.ships[i]; // Здесь мы получаем объект корабля. Необходимо проверить, совпадают ли
    		                        	// координаты выстрела с координатами одной из занимаемых им клеток.
    		//!!!var locations = ship.locations; // Получаем массив клеток, занимаемых кораблем. (это свойство, в котором массив)
    		
    		//ЗДЕСЬ мы могли просто создать еще один цикл, который перебирает массив locations и сравнивает каждый эдемент с guess, и если значения совпадают, то выстрел попал в цель
    		//НО СДЕЛАЕМ ИНАЧЕ:
    		//!!!var index = locations.indexOf(guess); //Метод indexOf ищет в массиве указанное значение и возвращает его индес (или -1, если значение отсутствует в массиве). Обратите внимание на сходство метода indeOf массива с методом IndexOf строки.Оба метода получают значение и возвращают индекс (или -1, если значение не найден0)
 			//СОКРАЩАЕМ 2 СТРОКИ ВЫШЕ:
 			var index = ship.locations.indexOf(guess); //Две выделенные строки выше объдинены в одну строку.

 			if (index >= 0) {
 				//Есть попадание! ***Если полученный индекс больше либо равен нулю, значит указанная клетка присутствует в массиве location и выстрел попал в цель.
 				ship.hits[index] = "hit"; //Ставим отметку в массиве hits по томуже ВЫЧИСЛЕННОМУ индексу через indexOf выше.
 				
 				//Оповещаем представление о том, что в клетке guess следует вывести маркер попадания.
 				view.displayHit(guess);
 				//И приказываем представлению вывести сообщение "HIT!"
 				view.displayMessage("HIT!");
 				
 				//Здесь добавили проверку, после того как будем точно знать, что выстрел попал в корабль. Если корабль
 				//потоплен, то мы увеличиваем счетчик потопленных кораблей в свойстве shipsSunk модели.
 				if (this.isSunk(ship)) {
 					//Сообщаем игроку, что он потопил корабль!
 					view.displayMessage("You sank my battleship!");
 					this.shipsSunk++;
 				}
 				
 				return true; //А еще нужно вернуть true, потому что выстрел оказался удачным.
 			}	
    	}
    	//Сообщаем представлению, что в клетке guess следует вывести маркер промаха!
    	view.displayMiss(guess);
    	//И приказываем представлению вывести сообщение о промахе
    	view.displayMessage("You missed.");
    	//***??? - Методы объекта представления добавляют класс "hit" или "miss" к элементу с идентификатором, 
    	//содержащимся в guess. Таким образом, представление преобразует "попадания" из массива hits в разметку HTML. 
    	//Не забывайте, что HTML - "попадания" нужны для отображения информации, а "попадания" в модели представляют
    	//фактическое состояние.

    	return false; //Если же после перебора всех кораблей попадание так и не обнаружено, игрок промахнулся, а метод возвращает false.
    },

   //Метод получает объект корабля и возвращает true, если корабль потоплен, или false, если он еще держится на плаву.
    isSunk: function(ship) { //Проверяем объект-корабль, помечены ли все его клетки маркером попадания hit.
    	for (var i = 0; i < this.shipLength; i++) {
    		if (ship.hits[i] !== "hit") {
    			return false; //Если есть хотя бы одна клетка, в которую не попали, то корабль жив, и метод возвращает false
    		}
    	}
    	return true; //А если нет - корабль потоплен! Метод возвращает true.
    	//ДОБАВИМ ЭТОТ МЕТОД В ОБЪЕКТ МОДЕЛИ, сразу же за методом fire!
    }
};

model.fire("53");

model.fire("06");
model.fire("16");
model.fire("26");

model.fire("34");
model.fire("24");
model.fire("44");

model.fire("12");
model.fire("11");
model.fire("10");


}
window.onload = init; 


