// ЗАМЫКАНИЯ!
// Это функция, объявленная внутри функции, благодаря которой локальные переменные
// внутри старшей функции не сбрасываются после завершении работы этой функции, а
// остаются при повторном вызове.
// Замыканием они называются потому, что младшая функция их замыкает внутри старшей.

// БОЛЕЕ ДЕТАЛЬНО:
// Замыкание возникает тогда, когда функция, содержащая свободные переменные, объединяется
// с окружением, которое предоставляет привязки для всех свободных переменных...

// ***НЕ ПРАВИЛЬНАЯ*** РЕАЛИЗАЦИЯ СЧЕТЧИКА ЧЕРЕЗ ГЛОБАЛЬНУЮ ПЕРЕМЕННУЮ:
var count = 0; // Глобальная переменная count (НАПОМНЮ, что так делать нельзя!) Т.к. 
			   // такаяже переменная может встретится в коде и возникнут ошибки.

function counter() {
	count = count + 1;
	return count;
}

//Последовательно увеличиваем и выводим значение счетчика в консоль
console.log(counter()); // 1
console.log(counter()); // 2
console.log(counter()); // 3


// ***ПРАВИЛЬНАЯ*** РЕАЛИЗАЦИИ СЧЕТЧИКА С ИСПОЛЬЗОВАНИЕМ ЗАМЫКАНИЯ  :
function makeCounter() {
	var count = 0; // Переменная count помещается в функцию makeCounter. Теперь count
				   // становится локальной, а не глобально переменной.
	function counter() { // Создаем функцию counter, которая увеличивает переменную count
		count = count + 1;
		return count; // Возвращаем count 
	}
	return counter; // И возвращаем функцию counter (ВНИМАНИЕ! Не результат выполнения "counter()", а
					// именно функцию! "counter" )
					// ЭТО ЗАМЫКАНИЕ: значение count сохраняется в его окружении.
}

var doCount = makeCounter();  // Т.к. counter возвращает функцию, то мы присваиваем ее переменной doCount
console.log(doCount()); // 1
console.log(doCount()); // 2
console.log(doCount()); // 3

console.log(makeCounter()()); // 1  Мы вызвали код функции, а вторыми ДОПОЛНИТЕЛЬНЫМИ скобками сразу его исполнили


// УПРАЖНЕНИЕ 1:
//  Функция makePassword получает пароль в аргументе и возвращает функцию, которая принимает введенную строку
//  и возвращает true, если введенная строка совпадает с паролем (иногда, чтобы понять суть замыкания, приходится
//  перечитыватьт описание несколько раз:)

 // Функция, возвращаемая из makePassword, представляет собой замыкание с окружением, содержащим 
 // свободную переменную pasword.
function makePassword(password) {
	return function guess(paswordGuess) { // Обратите внимание! Используется именованное функциональное выражение. Это
										  // не обязательно, но удобно для ссылок на имя внутренней функции. 
										  // Возвращаемая функция ДОЛЖНА вызываться tryGuess (а не guess)
		return (paswordGuess === password);
	};
}

 // Мы передаем makePassword значение "secret", которое сохраняется в окружении ЗАМЫКАНИЯ.
var tryGuess = makePassword('secret');
console.log("Guessing 'nope': " + tryGuess("nope"));
console.log("Guessing 'secret': " + tryGuess("secret")); // ПРи вызове tryGuess переданное слово ("nope" или "secret")
														// сравнивается со значением password в окружении tryGuess


// УПРАЖНЕНИЕ 2:
// Функция multN получает число (назовем его n) и возвращает функцию, которая также получает число, умнажает
// его на n и возвращает результат.

function multN(n) {
	return function multBy(m) {
		return n * m;
	};
}

var multBy3 = multN(3);
console.log(multBy3(2));

// УПРАЖНЕНИЕ 3:
// Разновидность счетчика, созданного ранее в этой главе. Функция makeCounter не получает аргументов, но определяет 
// переменную count. Затем она создает и возвращает объект с единственным методом increment. Этот метод увеличивает
// переменную count и возвращает ее.
function makeCounter2() {
	var count = 1; 
	obj = {
		increment: function() {
			count++;
			return count;
		}
	}; 
	return obj.increment; //ВОЗВРАЩАЕМ КОД МЕТОДА
	}
	


var counterIncrement = makeCounter2();  

console.log(counterIncrement()); // 2
console.log(counterIncrement()); // 3
console.log(counterIncrement()); // 4


// ЗАМЫКАНИЕ с передачей ФУНКЦИОНАЛЬНОГО ВЫРАЖЕНИЯ в аргументе
// Замыкания могут также создаваться передачей ФУНКЦИЙ при вызове функций. Передаваемая функция выполняется
// в контексте, отличном от контекста ее создания. Пример:
function makeTimer(doneMessage, n) {

	setTimeout(function() { // Имеется фукнция...
		alert(doneMessage); // ..со свободной переменной, которая используется как обработчик
							// ..при вызове setTimeout
	}, n);
}

makeTimer("Cookies are done!", 1000); // Эта функция будет выполнена через 1000 миллисекунд, когда функция
									  // makeTimer давно завершится
//ПОЯСНЕНИЕ ПРИМЕРА ВЫШЕ:
 // Функциональное выражение, сождержащее свободную переменную doneMessage, передается функции setTimeout. Как вам известно, при
 // этом функциональное выражение обрабатывается для получения ссылки на функцию, которая затем передается setTimeout. метод
 // setTimeout сохраняет функцию (а вернее, функцию вместе с окружением - иначе говоря, замыкание), после чего через 1000 миллисекунд
 // вызывает ее.
 // И снова функция, передаваемая setTimeout, представляет собой замыкание, потому что вместе с ней предается окружение, связывающее
 // свободную переменную doneMessage со строкой Cookies are done!	


 								  

